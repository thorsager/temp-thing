/*
 * Click2CallGUI.java
 * 
 * Copyright (c) 2002-2007 Avaya Inc. All rights reserved.
 * 
 * USE OR INSTALLATION OF THIS SAMPLE DEMONSTRATION SOFTWARE INDICATES THE END
 * USERS ACCEPTANCE OF THE GENERAL LICENSE TERMS AVAILABLE ON THE AVAYA WEBSITE
 * AT http://support.avaya.com/LicenseInfo/ (GENERAL LICENSE TERMS). DO NOT USE
 * THE SOFTWARE IF YOU DO NOT WISH TO BE BOUND BY THE GENERAL LICENSE TERMS. IN
 * ADDITION TO THE GENERAL LICENSE TERMS, THE FOLLOWING ADDITIONAL TERMS AND
 * RESTRICTIONS WILL TAKE PRECEDENCE AND APPLY TO THIS DEMONSTRATION SOFTWARE.
 * 
 * THIS DEMONSTRATION SOFTWARE IS PROVIDED FOR THE SOLE PURPOSE OF DEMONSTRATING
 * HOW TO USE THE SOFTWARE DEVELOPMENT KIT AND MAY NOT BE USED IN A LIVE OR
 * PRODUCTION ENVIRONMENT. THIS DEMONSTRATION SOFTWARE IS PROVIDED ON AN AS IS
 * BASIS, WITHOUT ANY WARRANTIES OR REPRESENTATIONS EXPRESS, IMPLIED, OR
 * STATUTORY, INCLUDING WITHOUT LIMITATION, WARRANTIES OF QUALITY, PERFORMANCE,
 * INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * EXCEPT FOR PERSONAL INJURY CLAIMS, WILLFUL MISCONDUCT AND END USERS VIOLATION
 * OF AVAYA OR ITS SUPPLIERS INTELLECTUAL PROPERTY RIGHTS, INCLUDING THROUGH A
 * BREACH OF THE SOFTWARE LICENSE, NEITHER AVAYA, ITS SUPPLIERS NOR END USER
 * SHALL BE LIABLE FOR (i) ANY INCIDENTAL, SPECIAL, STATUTORY, INDIRECT OR
 * CONSEQUENTIAL DAMAGES, OR FOR ANY LOSS OF PROFITS, REVENUE, OR DATA, TOLL
 * FRAUD, OR COST OF COVER AND (ii) DIRECT DAMAGES ARISING UNDER THIS AGREEMENT
 * IN EXCESS OF FIFTY DOLLARS (U.S. $50.00).
 * 
 * To the extent there is a conflict between the General License Terms, your
 * Customer Sales Agreement and the terms and restrictions set forth herein, the
 * terms and restrictions set forth herein shall prevail solely for this Utility
 * Demonstration Software.
 */

//*****************************************************************************
//* Package
//*****************************************************************************

package sampleapps.click2call;

//*****************************************************************************
//* Imports
//*****************************************************************************

// Java swing and awt related classes.

import java.awt.Color;
import java.awt.BorderLayout;
import java.awt.FlowLayout;
import java.awt.GridLayout;
import java.awt.Container;
import java.awt.Font;
import java.awt.HeadlessException;
import java.awt.Component;

import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowAdapter;

import javax.swing.JButton;
import javax.swing.JTable;
import javax.swing.JScrollPane;
import javax.swing.JOptionPane;
import javax.swing.JFrame;
import javax.swing.ScrollPaneConstants;
import javax.swing.ListSelectionModel;
import javax.swing.JPanel;
import javax.swing.JLabel;

import javax.swing.table.DefaultTableCellRenderer;
import javax.swing.table.DefaultTableModel;

// Java utilities
import java.util.Map;
import java.util.TreeMap;
import java.util.Vector;
import java.util.ArrayList;

//*****************************************************************************
//* Click2CallGUI
//*****************************************************************************

/**
 * This class creates and manages call log GUI of Click2Call application.
 *  
 */
@SuppressWarnings("serial")
public class Click2CallGUI extends JFrame implements TableConstants
{
    private JTable table; // table displaying incoming call data.
    private MyTableModel myTableModel;
    private static final Color BUTTON_BKGD_COLOR = new Color(80, 90, 170);
    private static final Color MISSED_CALL_COLOR = new Color(240, 200, 200);
    private static final Color DIALED_CALL_COLOR = new Color(255, 200, 100);
    private static final Color CALLED_BACK_CALL_COLOR =
        new Color(220, 180, 140);

    private CallStatus myCallStatus = null;       

    private Map<String, CallStatus> LampsCallStatus = new TreeMap<String, CallStatus>();

    /**
     * This is the constructor to get action listener which will listen to
     * events generated by this GUI and the two dimensional String array
     * containing initialization data.
     */
    public Click2CallGUI(ActionListener action_listener, String[][] log)
    {
        super("Click2Call");

        // obtain the ContentPane and set BorderLayout.
        Container contentpane = getContentPane();
        contentpane.setLayout(new BorderLayout());

        // Set table header and data.
        String[] tableHeader =
            { "Name", "Phone Number", "Call Time", "Call Status" };
        String[][] tableData;

        // if log is null, display empty table otherwise initialize the JTable
        // with data in log file.
        if (log == null)
        {            
            tableData = new String[0][0];
        }
        else
        {
            tableData = log;
        }

        table = new JTable();

        table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);

        // set table model, foreground, background, font etc.
        myTableModel = new MyTableModel(tableData, tableHeader);
        table.getTableHeader().setReorderingAllowed(false);
        table.getTableHeader().setBackground(Color.WHITE);
        table.getTableHeader().setFont(
            new Font(
                table.getTableHeader().getFont().getName(),
                Font.BOLD,
                10));
        table.setGridColor(BUTTON_BKGD_COLOR);
        table.setModel(myTableModel);

        // set table cell renderer for using custom colors in table cells
        // depending upon cell data.
        table.setDefaultRenderer(
            table.getColumnClass(0),
            new ColoredTableCellRenderer());

        // create scroll pane, add table to it.
        int v = ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED;
        int h = ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED;

        JScrollPane jsp = new JScrollPane(table, v, h);

        jsp.getViewport().setBackground(Color.WHITE);

        // Create a panel and add various buttons to it. Actions generated
        // by these buttons are sent to action_listener.
        JPanel jp1 = new JPanel();
        jp1.setLayout(new FlowLayout());
        jp1.setBackground(Color.white);

        JButton jb = new JButton("Call Back");
        jb.setActionCommand("callback");
        jb.addActionListener(action_listener);
        jb.setBackground(BUTTON_BKGD_COLOR);
        jb.setForeground(Color.WHITE);
        jp1.add(jb);

        jb = new JButton("Delete");
        jb.setActionCommand("delete");
        jb.addActionListener(action_listener);
        jb.setBackground(BUTTON_BKGD_COLOR);
        jb.setForeground(Color.WHITE);
        jp1.add(jb);

        jb = new JButton("Delete All");
        jb.setActionCommand("deleteall");
        jb.addActionListener(action_listener);
        jb.setBackground(BUTTON_BKGD_COLOR);
        jb.setForeground(Color.WHITE);
        jp1.add(jb);

        JPanel jp2 = new JPanel();
        JLabel jl =
            new JLabel(
                "Please select a table row"
                    + " and click \"Call Back\" to make the call.");
        jl.setForeground(BUTTON_BKGD_COLOR);
        jl.setFont(new Font(jl.getFont().getName(), Font.BOLD, 16));

        jp2.setLayout(new FlowLayout());
        jp2.setBackground(Color.white);
        jp2.add(jl);

        // add various panels and scroll pane to content pane.
        contentpane.add(jp2, BorderLayout.NORTH);
        contentpane.add(jsp, BorderLayout.CENTER);
        contentpane.add(jp1, BorderLayout.SOUTH);

        // set size of content pane and display it.
        setSize(800, 400);

        setVisible(true);

        // add custom window listener to exit the application if GUI is closed.
        addWindowListener(new MyWindowAdapter());

        JFrame.setDefaultLookAndFeelDecorated(true);
    }

    /**
     * Deletes a single row. Take different actions depending upon whether a
     * row is selected to be deleted or not.
     */
    public void delete()
    {
        int selectedRowIndex = table.getSelectedRow();

        // if no row is selected, selectedRowIndex would be -1
        if (selectedRowIndex == -1)
        {
            JOptionPane.showMessageDialog(
                null,
                "Please select a table row to delete.",
                "Delete Error",
                JOptionPane.ERROR_MESSAGE);            
        }
        else
        {
            myTableModel.removeRow(selectedRowIndex);
        }
    }

    /**
     * Deletes all rows of table, i.e., delete all calls logged.
     */
    public void deleteAll()
    {
        int rowCount = table.getRowCount();

        for (int i = rowCount - 1; i >= 0; i--)
        {
            myTableModel.removeRow(i);
        }
    }

    /**
     * Propmts the user to enter an access code (if required) to make the call.
     * 
     * @return access code required to make the call
     */
    public String getAccessCode()
    {
        String accessCode;

        try
        {
            accessCode =
                (String) JOptionPane.showInputDialog(
                    "If you have to dial an access code \n"
                        + "before dialing this number, please \n"
                        + "enter it now.");

            return accessCode;
        }
        catch (HeadlessException hle)
        {
            System.out.println(
                "An exception occured while obtaining" + "access code");
            hle.printStackTrace();
            return null;
        }
    }

    /**
     * Handles the functionality related to making a call, makes appropriate
     * changes, displays various messages to user.
     */
    public void callBack(String number)
    {
        // If no row is selected, prompt the user to select a row first.
        if ((number == null) && (table.getSelectedRow() == -1))
        {
            JOptionPane.showMessageDialog(
                null,
                "Please select a number (table row) to call.",
                "Call Error",
                JOptionPane.ERROR_MESSAGE);            
        }
        else if (number == null)
        {
            // User pressed cancel when prompted for access code.
            System.out.println("Call canceled");
        }
        else if (number.trim().length() == 0)
        {
            // Check if callee number is valid, if length of number is greater
            // than 0, other checks (to determine if it is a valid number
            // string) are done in Click2Call.java
            JOptionPane.showMessageDialog(
                null,
                "Invalid callee number.",
                "Call Error",
                JOptionPane.ERROR_MESSAGE);
        }
        else
        {
            int selectedRowIndex = table.getSelectedRow();

            // check that the calling party matches the selected row
            // row remains selected if a call was made in the ldap lookup window
            String calledBackNumber = (String) table.getValueAt(selectedRowIndex,
                    CallLogTableConstants.NUMBER_COLUMN_INDEX);
            if (number.trim().equalsIgnoreCase(calledBackNumber)) {
                
            // The call went through, change call status.
            if (((String) table
                .getValueAt(
                    selectedRowIndex,
                    CallLogTableConstants.STATUS_COLUMN_INDEX))
                .equals("Missed"))
            {
                table.setValueAt(
                    "Called back",
                    selectedRowIndex,
                    CallLogTableConstants.STATUS_COLUMN_INDEX);

            }
            else
            {
                table.setValueAt(
                    "Dialed",
                    selectedRowIndex,
                    CallLogTableConstants.STATUS_COLUMN_INDEX);

            }
        }
    }
    }

    /**
     * General purpose method used to display message on GUI in appropriate
     * JOptionPane type.
     * 
     * @param msgType
     *            Error or message
     * @param msg
     *            message
     */
    public void displayMessage(int msgType, String msg)
    {
        if (msg != null)
        {
            switch (msgType)
            {
                case JOptionPane.ERROR_MESSAGE :
                    {
                        JOptionPane.showMessageDialog(
                            null,
                            msg,
                            "Error",
                            JOptionPane.ERROR_MESSAGE);
                        break;
                    }
                default :
                    {
                        JOptionPane.showMessageDialog(
                            null,
                            msg,
                            "Message",
                            JOptionPane.INFORMATION_MESSAGE);
                    }
            }
        }
    }

    /**
     * Display a received call in table.
     * 
     * @param name
     *            name to display for this call
     * @param number
     *            number to display for this call
     * @param time
     *            time to display for this call
     * @param callType
     *            Answered/Missed
     */
    public void displayCall(
        String name,
        String number,
        String time,
        String callType)
    {

        Vector<String> temp = new Vector<String>(4, 0);

        temp.add(name);
        temp.add(number);
        temp.add(time);
        temp.add(callType);

        myTableModel.insertRow(0, temp);

    }

    /**
     * Used to obtain the number to call back when user hits "CallBack" button.
     * 
     * @return String number to call, null if no row is selected.
     * @throws Exception
     *             if user enters an invalid access code, for example an
     *             alphabet.
     */
    public String getNumberToCall() throws Exception
    {
        int selectedRowIndex = table.getSelectedRow();

        // no row is selected, return null.
        if (selectedRowIndex == -1)
        {
            return null;
        }
        else
        {
            String accessCode = getAccessCode();

            // User pressed cancel when prompted for access code, so return
            // null
            // to cancel the call.
            if (accessCode == null)
            {
                return null;
            }
            else
            {
                accessCode = accessCode.trim();
            }

            if (accessCode.length() == 0)
            {
                return (String) table.getValueAt(
                    selectedRowIndex,
                    CallLogTableConstants.NUMBER_COLUMN_INDEX);
            }
            else
            {
                // Check if the access code is a number
                try
                {
                    Integer.parseInt(accessCode);
                }
                catch (NumberFormatException nfe)
                {
                    JOptionPane.showMessageDialog(
                        null,
                        "Invalid access code",
                        "Call Error",
                        JOptionPane.ERROR_MESSAGE);

                    throw new Exception("Invalid access code.");
                }
                return accessCode
                    + (String) table.getValueAt(
                        selectedRowIndex,
                        CallLogTableConstants.NUMBER_COLUMN_INDEX);
            }
        }
    }

    /**
     * Obtains and returns the name (as obtained from lampUpdates) of callee.
     * 
     * @return String name of callee.
     */
    public String getNameToCall()
    {
        int selectedRowIndex = table.getSelectedRow();

        if (selectedRowIndex == -1)
        {
            return null;
        }
        else
        {
            return (String) table.getValueAt(
                selectedRowIndex,
                CallLogTableConstants.NAME_COLUMN_INDEX);
        }
    }

    /**
     * Obtains and returns index of selected row, -1 if no row is selected.
     * 
     * @return int selected row index, null if no row is selected.
     */
    public int getSelectedRowIndex()
    {
        return table.getSelectedRow();
    }

    /**
     * Displays the status of a call if the call is successfully made. User can
     * disconnect the call by pressing HangUp button.
     * 
     * @param al
     *            action listener of this status window
     * @param calledNumber
     *            called number
     * @param calleeName
     *            name of the callee
     * @param callAppearance
     *            call appearance in use for this call.
     */
    public void displayCallStatus(
        ActionListener al,
        String calledNumber,
        String calleeName,
        String callAppearance)
    {
    	LampsCallStatus.put(callAppearance, new CallStatus(al, calledNumber, calleeName, callAppearance));
    }      
    
    /**
     * Remove the status of a call if the call was disconnected by far end.
     *      
     * @param lampID
     *            lamp id of this call.
     */
    public void removeCallStatus(String lampID)
    {
    	CallStatus status = LampsCallStatus.remove(lampID);
        if (status != null)
        {
            status.dispose();
        }
    } 

    /**
     * Obtains and returns call data displayed in the table.
     * 
     * @return ArrayList containing table data.
     */
    public ArrayList<Object> getTableData()
    {
        ArrayList<Object> tableData = new ArrayList<Object>();

        for (int i = 0; i < table.getRowCount(); i++)
        {
            for (int j = 0; j < CallLogTableConstants.TABLE_COLUMN_COUNT; j++)
            {
                tableData.add(table.getValueAt(i, j));
            }
        }

        return tableData;
    }

    /**
     * Obtains and returns data related to call to be disconnected when user
     * presses HangUp button on status window.
     * 
     * @param actionSource
     *            HangUp button on call status window which generated event.
     * @return ArrayList containing data related to the call being
     *         disconnected.
     * @throws ClassCastException
     *             if invalid action source is received.
     */
    public ArrayList<String> whichCallToDisconnect(Object actionSource)
        throws ClassCastException
    {
        CallStatus temp = null;
        JButton tb;
        ArrayList<String> callData = new ArrayList<String>(2);

        tb = (javax.swing.JButton) actionSource;

        // get reference to callStatus window displaying the status of this
        // call.
        temp = (CallStatus) tb.getRootPane().getParent();

        // get called number and call appearance in use for this call.
        callData.add(temp.getCalledNumber());
        callData.add(temp.getCallAppearance());

        // release resources in use by this callStatus window.        
        LampsCallStatus.remove(temp.callAppearance);
        temp.dispose();

        return callData;
    }

    public void closeWindow() {
    	if (myCallStatus != null) {
    		myCallStatus.dispose();
    		myCallStatus = null;
    	}   	
    }
    
 
    /**
     * Provides custom table model to initialize table and set the data in
     * cells uneditable.
     */
    private class MyTableModel extends DefaultTableModel
    {
        public MyTableModel(Object[][] data, Object[] header)
        {
            super(data, header);
        }

        public boolean isCellEditable(int row, int column)
        {
            return false;
        }
    }

    /**
     * Provides custom table cell renderer which enables the application to
     * display Answered and Missed calls in different colors.
     */
    private class ColoredTableCellRenderer extends DefaultTableCellRenderer
    {
        public Component getTableCellRendererComponent(
            JTable table,
            Object value,
            boolean selected,
            boolean focused,
            int row,
            int column)
        {
            setEnabled(table == null || table.isEnabled());

            // display missed call in different color than answered calls.
            if (((String) table.getValueAt(row, 3)).trim().equals("Missed"))
            {
                setBackground(MISSED_CALL_COLOR);
            }
            else if (
                ((String) table.getValueAt(row, 3)).trim().equals("Dialed"))
            {
                setBackground(DIALED_CALL_COLOR);
            }
            else if (
                ((String) table.getValueAt(row, 3)).trim().equals(
                    "Called back"))
            {
                setBackground(CALLED_BACK_CALL_COLOR);
            }
            else
            {
                setBackground(Color.WHITE);
            }

            super.getTableCellRendererComponent(
                table,
                value,
                selected,
                focused,
                row,
                column);

            return this;
        }
    }

    /**
     * Custom window adapter to exit the application if gui is closed.
     */
    private class MyWindowAdapter extends WindowAdapter
    {
        public void windowClosing(WindowEvent we)
        {
            setVisible(false);
            System.exit(0);
        }
    }

    /**
     * This class renders JFrame used to display status of a call after a call
     * is successfully made. It contains called number and corresponding call
     * appearance in use to facilitate disconnecting a call.
     */
    private class CallStatus extends JFrame
    {
        private String calledNumber;
        private String callAppearance;

        // window message name and number
        JPanel jp = null;
        JLabel messageName = null;
        JLabel messageNumber = null;
        private String calledPartyName;
        

        /**
         * Constructor stores called number, call appearance used in making
         * this call and callee name. Action listener to be registered for
         * listening events generated here is received as parameter.
         * 
         * @param action_listener
         * @param calledNumber
         * @param calleeName
         * @param callAppearance
         */
        public CallStatus(
            ActionListener action_listener,
            String calledNumber,
            String calleeName,
            String callAppearance)
        {
            super("Call Status");

            Container contentpane = getContentPane();
            contentpane.setLayout(new GridLayout(1, 0));

            jp = new JPanel();
            jp.setLayout(new GridLayout(3, 0));
            jp.setBackground(Color.WHITE);

            calledPartyName = calleeName;
            messageName = new JLabel("Calling.... " + calleeName);
            messageNumber = new JLabel("(" + calledNumber + ")");
            jp.add(messageName);
            jp.add(messageNumber);

            JButton jb = new JButton("Hang Up");
            jb.setActionCommand("hangup");
            jb.addActionListener(action_listener);
            jb.setBackground(BUTTON_BKGD_COLOR);
            jb.setForeground(Color.WHITE);
            jp.add(jb);

            contentpane.add(jp);

            JFrame.setDefaultLookAndFeelDecorated(true);

            this.calledNumber = calledNumber;
            this.callAppearance = callAppearance;

            setSize(300, 100);
            setVisible(true);
        }

        public void setConnectedStatus() {
        	if (messageName != null) {
        		messageName.setText("Connected to " + calledPartyName);
            	jp.updateUI();
        	}
        	
        }

        /**
         * This method returns called number displayed in this status frame.
         * 
         * @return String called number
         */
        public String getCalledNumber()
        {
            return this.calledNumber;
        }

        /**
         * This method returns call appearance in use for making this call.
         * 
         * @return String call appearance.
         */
        public String getCallAppearance()
        {
            return this.callAppearance;
        }

    }

}
